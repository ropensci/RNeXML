\documentclass[author-year, review, 11pt]{components/elsarticle} %review=doublespace preprint=single 5p=2 column
%%% Begin My package additions %%%%%%%%%%%%%%%%%%%
\usepackage[hyphens]{url}
\usepackage{lineno} % add 
\bibliographystyle{elsarticle-harv}
\biboptions{sort&compress} % For natbib
\usepackage{graphicx}
\usepackage{booktabs} % book-quality tables
%% Redefines the elsarticle footer
\makeatletter
\def\ps@pprintTitle{%
 \let\@oddhead\@empty
 \let\@evenhead\@empty
 \def\@oddfoot{\it \hfill\today}%
 \let\@evenfoot\@oddfoot}
\makeatother

% A modified page layout
\textwidth 6.75in
\oddsidemargin -0.15in
\evensidemargin -0.15in
\textheight 9in
\topmargin -0.5in
%%%%%%%%%%%%%%%% end my additions to header

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \usepackage{fontspec}
  \ifxetex
    \usepackage{xltxtra,xunicode}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textbf{{#1}}}
\newcommand{\NormalTok}[1]{{#1}}
\usepackage{graphicx}
% We will generate all images so they have a width \maxwidth. This means
% that they will get their normal width if they fit onto the page, but
% are scaled down if they would overflow the margins.
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
\else\Gin@nat@width\fi}
\makeatother
\let\Oldincludegraphics\includegraphics
\renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=\maxwidth]{#1}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={RNeXML: a package for reading and writing richly annotated phylogenetic, character, and trait data in R},
            colorlinks=true,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}
% Pandoc toggle for numbering sections (defaults to be off)
\setcounter{secnumdepth}{0}
% Pandoc header



\begin{document}
\begin{frontmatter}

  \title{RNeXML: a package for reading and writing richly annotated phylogenetic,
character, and trait data in R}
    \author[cstar]{Carl Boettiger\corref{c1}}
   \ead{cboettig(at)gmail.com} 
   \cortext[c1]{Corresponding author}
    \author[NESCent]{Hilmar Lapp}
  
  
    \author[ropensci]{Scott Chamberlain}
  
  
    \author[NBC]{Rutger Vos}
  
  
      \address[cstar]{Center for Stock Assessment Research, Department of Applied Math and
Statistics, University of California, Mail Stop SOE-2, Santa Cruz, CA
95064, USA}    
    \address[NESCent]{National Evolutionary Synthesis Center, Durham, NC, USA}    
    \address[ropensci]{University of California, Berkeley, CA, USA}    
    \address[NBC]{Naturalis Biodiversity Center, Leiden, the Netherlands}    
  
  \begin{abstract}
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \item
    NeXML is a new phylogenetic informatics data and metadata exchange
    format that offers substantial improvements in reliability,
    extensibility, and richness over earlier formats such as NEXUS. In
    this paper we present the RNeXML package which provides a bridge
    between this rich and reliable data format and the extensive library
    of phylogenetic tools already available in R, with a particular
    emphasis on comparative methods.
  \item
    RNeXML is much richer than a basic parser: here we illustrate how the
    package facilitates adding and manipulating semantic annotations, that
    is annotations whose meaning can be defined externally by way of
    semantic web technologies.
  \item
    An essential feature of NeXML is to provide both the flexibility to be
    continually extended to meet the emerging needs of the phylogenetics
    community while remaining backwards-compatible with software developed
    for earlier versions. Here we illustrate how RNeXML makes it easy to
    extend NeXML in this manner.
  \item
    RNeXML is well suited for users to preserve and maintain their
    personal archives of phylogenetic and comparative trait data in
    consistent, query-able, and cross-platform format, to leverage the
    rapidly growing public community archives of rich NeXML files, and to
    interact with web services that deliver their results (with their
    provenance) as NeXML.
  \end{enumerate}
  \end{abstract}
  
 \end{frontmatter}


\section{Introduction}\label{introduction}

Though R provides the most extensive and widely used collection of
comparative phylogenetic methods tools, R users lack a convenient,
extensible format to exchange and archive comparative methods data. A
common file format for sharing phylogenetic tree data has long played an
essential role in the advancement of phylogenetics research. The rapid
increase in phylogenetics data and research methods that make use of
such data has introduced many new challenges and opportunities to
sharing this information both between software environments and between
research groups (Stoltzfus \emph{et al.} 2012; Drew \emph{et al.} 2013).

The ever expanding needs of the phylogenetics community are rapidly
out-pacing the capacity of current standards, which is resulting in a
radiation of different data representations and a loss of
interoperability at the very time when the growth of available data and
methods has made that interoperability most valuable.

For example, the currently popular NEXUS file format cannot consistently
represent horizontal gene transfer or ambiguity in reading a character
(such as a DNA sequence base pair). This has led developers to
repeatedly add small modifications to the standard to meet the needs of
their own software, which results in mutually incompatible dialects that
largely defeat the advantages of a shared file format. NeXML was
developed to addresses each of these problems (Vos \emph{et al.}
2012)\\by drawing on robust web standards in data representation. The
design and expressiveness of NeXML makes it much easier to meet the
rising bar for best practices in data sharing in phylogenetic research
(Cranston \emph{et al.} 2014).

The R language (R Core Team 2014) has become an important environment
for phylogenetics research, with over 30 packages available including
several with over 1000 citations (O'Meara 2014), though stand-alone
programs remain an important part of this ecosystem for tasks such as
generating phylogenetic trees from sequence data. Within this ecosystem
a variety of different data formats for phylogenetic data have been
developed and modified. Most but not all are based on the simple and
popular \texttt{ape::phylo} format provided by the ape package (Paradis
\emph{et al.} 2004).

Though certain functions allow R users to switch between these formats
within R, these formats frequently contain more information than their
NEXUS file counterparts, and users lack a suitable alternative for
archiving and sharing phylogenetic data outside of the R ecosystem.
Consequently, information added to phylogenies by these R programs
cannot easily be shared, archived, and made available to other software;
but inherits the limitations of the NEXUS format.

\texttt{RNeXML} opens up a rich world of both currently available and
rapidly growing data sets in the NeXML format to the R user and the
large ecosystem of R packages currently available for handling
phylogenetic data.\\ R packages and R users frequently add rich
information to the phylogenies they work with, but need a platform
independent data exchange format to share and archive this. We
illustrate how NeXML can be used to distribute both phylogenies and
character trait data used in many popular phylogenetic comparative
methods tools in R.\\\texttt{RNeXML} also provides convenient tools for
adding metadata to NeXML files, including the automated generation of
metadata and examples of how to extend the NeXML standard to represent
new data features without breaking validation or backwards compatibility
of the file type.

In this paper, we introduce the reader to the concepts and use of RNeXML
and related technologies. We begin by discussing methods to read
phylogenetic tree data and character trait data in the NeXML format into
R, and also how to write phylogenetic data and character trait data into
NeXML. The heart of this section focuses on tools for reading and
writing the kind of semantically rich metadata that most sets NeXML
apart from other phylogenetic data formats. Starting simple, we use
examples of increasing complexity to illustrate concepts and tools from
biodiversity informatics that allow users to express and interpret
complicated data structures automatically. We end with an example that
uses metadata to extend the NeXML standard to describe stochastic
character mapping, one of the kinds of data annotation that is currently
available in R formats but lacks a consistent, extensible export format.
We illustrate how NeXML files can be formally published to a data
repository directly from R. Finally, we provide a brief description of
how the software has been implemented, what quality control measures are
in place, as well as information about software reuse and getting
support.

This paper has been written as a dynamic document (Xie 2013). The reader
may paste the code blocks shown into their R terminal to follow along
with the exmples shown.

\section{Introduction to RNeXML}\label{introduction-to-rnexml}

A NeXML document can be thought of as having multiple components: (1)
phylogeny data (2) character-trait data, (3) operational taxonomic
units, and (4) metadata. \texttt{RNeXML} seeks to provide a seamless way
to convert these to and from their corresponding R object
representations, such as \texttt{ape::phylo} phylogenies, character
matrices (\texttt{data.frames}) and metadata lists (or for advanced
users, \texttt{XMLInternalDocument} and \texttt{rrdf} triplestores).
Metadata can provide information about the study in which the phylogeny
was generated or applied (such as authors, citations to publications,
timestamps, and even descriptions of methods), but can also be used to
annotate individual data components. We illustrate how metadata
annotations can be added to the operational taxonomic units of the
phylogeny and can be used to extend the data representation to new uses
such as stochastic character maps.

\subsection{Getting Started}\label{getting-started}

The current stable version of the \texttt{RNeXML} package can be
installed from the CRAN library\footnote{By providing the optional
  \texttt{dependencies} argument, R will install additional packages
  used in some of the advanced examples shown later but which are not
  required for basic functionality.}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"RNeXML"}\NormalTok{, }\DataTypeTok{dependencies=}\OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Reading phylogenetic
trees}\label{reading-phylogenetic-trees}

We begin by loading the \texttt{RNeXML} package and reading in an
example NeXML file provided with the package, containing two small
phylogenetic trees.\footnote{For convenience \texttt{nexml\_read} is
  also aliased as \texttt{read.nexml}, for users familiar with the
  somewhat analogous \texttt{read.nexus} function.}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"RNeXML"}\NormalTok{)}
\NormalTok{f <-}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\StringTok{"examples"}\NormalTok{, }\StringTok{"trees.xml"}\NormalTok{, }\DataTypeTok{package=}\StringTok{"RNeXML"}\NormalTok{)}
\NormalTok{nex <-}\StringTok{ }\KeywordTok{nexml_read}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

The resulting \texttt{nex} object is an R object representation of the
NeXML. This is a native R object, of the \texttt{nexml} class, for
representing phylogenetic trees (as well as character traits, and
metadata), analogous to the \texttt{ape::phylo} object from the popular
\texttt{ape} R package (Paradis \emph{et al.} 2004). While R functions
and packages could be written to use this \texttt{nexml} object
directly, most users will prefer to use already existing methods
provided by packages they know. From a \texttt{nexml} object, we can
therefore extract any phylogenies it contains in the \texttt{ape::phylo}
format. In this case we will get back a \texttt{multiPhylo} object,
since the file contains two phylogenies.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phy <-}\StringTok{ }\KeywordTok{get_trees}\NormalTok{(nex)}
\end{Highlighting}
\end{Shaded}

We can then leverage the rich suite of methods available from the R
phylogenetics community. For instance, here we use the standard plotting
function from the \texttt{ape} package to plot the first tree in the
resulting \texttt{ape::phylo} object returned by \texttt{get\_trees}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(phy[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

NeXML can not only contain multiple phylogenetic trees in a single
document, but can also group sets of trees into separate blocks (e.g.~as
resulting from different workflows). The \texttt{get\_trees()} function
attempts to return the most sensible R object for NeXML: if only a
single tree is available, it will return an \texttt{ape::phylo} object;
if multiple trees are available in a single \texttt{trees} block, it
will return an \texttt{ape::multiPhylo} object (a list of
\texttt{ape::phylo} objects). If multiple blocks are available, it will
return a list of \texttt{multiPhylo} blocks. While most users will find
this behavior convenient, there are times (such as looping over many
NeXML files) when having a variable return type is undesirable. To
always get back a list of \texttt{multiPhylo} objects, even when only
one tree is available, use \texttt{get\_trees\_list()}.

The ability to read in phylogenetic trees in the NeXML format opens up a
wide and rapidly growing array of resources to the R user. For instance,
a user can access all the phylogenies available in
\href{http://treebase.org/treebase-web/home.html}{TreeBASE} through the
\texttt{nexml} format. \texttt{RNeXML} can read directly from a URL:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nex <-}\StringTok{ }\KeywordTok{nexml_read}\NormalTok{(}\StringTok{"https://raw.github.com/rvosa/supertreebase/master/data/treebase/S100.xml"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Previously, this was possible using the \texttt{treebase} package
(Boettiger \& {Temple Lang} 2012) for R, which relied on the NEXUS
parser provided in the \texttt{ape} package. Due to inconsistencies
present in the NEXUS standard (Vos \emph{et al.} 2012), a significant
number of TreeBASE NEXUS files could not be read in this way. Using the
more precisely defined NeXML standard, every valid NeXML document on
TreeBASE can now successfully be parsed to R objects.

\subsection{Reading character data}\label{reading-character-data}

Like NEXUS files, NeXML documents can also contain character data. While
most researchers will be familiar with the use of character matrices in
NEXUS files as a container for molecular sequence (or morphological)
data used to infer the phylogenetic tree, we find this ideal for
character data used in comparative methods popular in R. Methods to
extract character data work much like those for the phylogenetic data.
Here we read in an example NeXML file that contains both a phylogeny and
character data. \texttt{get\_characters()} returns a \texttt{data.frame}
with columns as characters and rows as taxa:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{comp_analysis <-}\StringTok{ }\KeywordTok{system.file}\NormalTok{(}\StringTok{"examples"}\NormalTok{, }\StringTok{"comp_analysis.xml"}\NormalTok{, }\DataTypeTok{package=}\StringTok{"RNeXML"}\NormalTok{)}
\NormalTok{nex <-}\StringTok{ }\KeywordTok{nexml_read}\NormalTok{(comp_analysis)}
\KeywordTok{get_characters}\NormalTok{(nex)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         log snout-vent length reef-dwelling
taxon_8                 -3.278             0
taxon_9                  2.096             1
taxon_10                 3.137             0
taxon_1                  4.753             1
taxon_2                 -2.762             0
taxon_3                  2.105             0
taxon_4                 -4.950             0
taxon_5                  1.271             1
taxon_6                  6.259             1
taxon_7                  0.910             1
\end{verbatim}

As this example shows, continuous and discrete characters are
represented as separate blocks in NeXML files, but will be combined as
separate columns of a single data frame by \texttt{get\_characters()} if
they correspond to the same taxa. The \texttt{get\_characters\_list()}
function will consistently receive a list of data frames corresponding
to each character matrix block of the NeXML.

\subsection{Writing phylogenetic
trees}\label{writing-phylogenetic-trees}

Generating NeXML files from R is likewise straightforward. Here we write
a phylogeny from the \texttt{ape::phylo} format out to a NeXML file:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(bird.orders)}
\KeywordTok{nexml_write}\NormalTok{(bird.orders, }\DataTypeTok{file =} \StringTok{"birds.xml"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "birds.xml"
\end{verbatim}

The first argument to \texttt{nexml\_write()} can be a
\texttt{ape::phylo} phylogeny, \texttt{multiPhylo} list of phylogenies,
or a \texttt{nexml} object -- anything that can be coerced into the
\texttt{nexml} class. As we have seen, NeXML files can contain multiple
phylogenetic trees, as well as character matrices. We can add both trees
and character data using \texttt{nexml\_write()},

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"geiger"}\NormalTok{)}
\KeywordTok{data}\NormalTok{(geospiza)}
\KeywordTok{nexml_write}\NormalTok{(}\DataTypeTok{trees =} \NormalTok{geospiza$phy, }\DataTypeTok{characters =} \NormalTok{geospiza$dat, }\DataTypeTok{file=}\StringTok{"geospiza.xml"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "geospiza.xml"
\end{verbatim}

These examples use data from the popular phylogenetics software
\texttt{geiger} (Harmon \emph{et al.} 2008).

NeXML files can also be built up bit by bit using
\texttt{add\_characters()}, \texttt{add\_trees()}, and
\texttt{add\_meta()}. Each of these functions can add data to an
existing \texttt{nexml} object or create a new nexml object if none is
provided. Here we first create a \texttt{nexml} object containing the
phylogeny data, and then add the character data to it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{geiger_nex <-}\StringTok{ }\KeywordTok{add_trees}\NormalTok{(geospiza$phy)}
\NormalTok{geiger_nex <-}\StringTok{ }\KeywordTok{add_characters}\NormalTok{(geospiza$dat, geiger_nex)}
\end{Highlighting}
\end{Shaded}

The data need not share the same taxa. We can append additional
phylogenies and characters corresponding to different taxa:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(primates)}
\NormalTok{geiger_nex <-}\StringTok{ }\KeywordTok{add_trees}\NormalTok{(primates$phy, geiger_nex)}
\NormalTok{geiger_nex <-}\StringTok{ }\KeywordTok{add_characters}\NormalTok{(primates$dat, geiger_nex)}
\end{Highlighting}
\end{Shaded}

This allows us to include multiple trees and character matrices to a
single NeXML file.

\section{Metadata}\label{metadata}

At the heart of the NeXML standard is the ability to encode arbitrary
metadata in precisely specified, machine-readable formats that maintain
backwards compatibility with any existing NeXML parser. NeXML uses the
``Resource Description Framework in Annotations'', or RDFa, as described
in Vos et al. (2012) or Prud'hommeaux (2014). These annotations can be
used to add information to any particular element of the data, (a tree,
node, edge, or taxonomic unit; a character matrix or specific trait, or
even another metadata annotation or the NeXML data file as a whole).
\texttt{RNeXML} provides a range of tools for accessing metadata
embedded in a NeXML file.

\subsection{Writing NeXML metadata}\label{writing-nexml-metadata}

Researchers cannot take advantage of NeXML metadata manipulation if
there is no metadata there. The burden of adding good metadata remains a
significant barrier to increased sharing and reuse of scientific
research (Tenopir \emph{et al.} 2011). \texttt{RNeXML} seeks to reduce
the burden of adding high quality, machine-readable metadata to NeXML
files. This occurs on several levels:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Automatic annotation
\item
  Adding common metadata fields (\texttt{add\_basic\_metadata})
\item
  Taxonomic identifiers (\texttt{taxize\_nexml})
\item
  Generic metadata (\texttt{add\_meta})
\item
  Extending the NeXML standard using RDFa
\end{itemize}

\texttt{RNeXML} automatically adds basic metadata by default such as a
time-stamp of when the tree was produced and an open data license (CC0,
compatible with deposition on Dryad data repository), which can be
configured as needed.

To adjust these and other common metadata fields that should be part of
any data deposition, \texttt{RNeXML} provides the
\texttt{add\_basic\_meta()} function. This function does not assume any
familiarity with the concepts of namespaces or other more advanced
metadata tools discussed later. The \texttt{add\_basic\_meta()} function
takes an existing \texttt{nexml} object (or will create a new one if
none is provided, like the other \texttt{add\_} functions), and any of
the following fields: \texttt{title}, \texttt{description},
\texttt{creator}, \texttt{pubdate}, \texttt{rights}, \texttt{publisher},
\texttt{citation}. Additional fields may be added to subsequent
versions, see \texttt{?add\_basic\_metadata} for the most up-to-date
information. Here we create a new \texttt{nexml} object with the basic
metadata for the \texttt{bird.orders} data provided in the \texttt{ape}
package:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(bird.orders)}
\NormalTok{birds <-}\StringTok{ }\KeywordTok{add_trees}\NormalTok{(bird.orders)}
\NormalTok{birds <-}\StringTok{ }\KeywordTok{add_basic_meta}\NormalTok{(birds,}
  \DataTypeTok{title =} \StringTok{"Phylogeny of the Orders of Birds From Sibley and Ahlquist"}\NormalTok{,}

  \DataTypeTok{description =} \StringTok{"This data set describes the phylogenetic relationships of the}
\StringTok{     orders of birds as reported by Sibley and Ahlquist (1990). Sibley}
\StringTok{     and Ahlquist inferred this phylogeny from an extensive number of}
\StringTok{     DNA/DNA hybridization experiments. The ``tapestry'' reported by}
\StringTok{     these two authors (more than 1000 species out of the ca. 9000}
\StringTok{     extant bird species) generated a lot of debates.}

\StringTok{     The present tree is based on the relationships among orders. The}
\StringTok{     branch lengths were calculated from the values of Delta T50H as}
\StringTok{     found in Sibley and Ahlquist (1990, fig. 353)."}\NormalTok{,}

  \DataTypeTok{citation =} \StringTok{"Sibley, C. G. and Ahlquist, J. E. (1990) Phylogeny and}
\StringTok{     classification of birds: a study in molecular evolution. New}
\StringTok{     Haven: Yale University Press."}\NormalTok{,}

  \DataTypeTok{creator =} \StringTok{"Sibley, C. G. and Ahlquist, J. E."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Citations can also be added using R's \texttt{bibentry} type, which
allows a user to add citations to R packages,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{birds <-}\StringTok{ }\KeywordTok{add_basic_meta}\NormalTok{(birds, }\DataTypeTok{citation =} \KeywordTok{citation}\NormalTok{(}\StringTok{"ape"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

or to papers by simply using the object's DOI (using Boettiger (2014)).
For instance to add the citation information of the paper that generated
the \texttt{geospiza} phylogeny included in the \texttt{geiger} package:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"knitcitations"}\NormalTok{)}
\NormalTok{geiger_nex <-}\StringTok{ }\KeywordTok{add_basic_meta}\NormalTok{(geiger_nex, }\DataTypeTok{citation =} \KeywordTok{bib_metadata}\NormalTok{(}\StringTok{"10.2307/2408428"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\subsection{Taxonomic identifiers}\label{taxonomic-identifiers}

\texttt{RNeXML} provides various functions to assist in automatically
adding other more specific metadata to various elements of the NeXML
data. One common use case is that of taxonomic identifiers. Misspellings
or inconsistent use of taxonomic names in phylogenetic data are a common
source of frustration in reusing phylogenetic trees, especially when
integrating data from different sources: trees might come from one place
that uses one taxonomy, character data and occurrence data might come
from other places that use different taxonomies. Hence, not just
misspellings, but also synonyms, homonyms and incompatible taxon
concepts might plague the end user. By associating the taxonomic labels
against a specific, centralized database we can catch some of these
inconsistencies and indicate more precisely which classification we are
appealing to in the event of conflicting taxonomic definitions. In this
example, we indicate that we intend the bird orders listed in the tree
to correspond to the NCBI definitions.

The \texttt{taxize\_nexml()} function uses the R package \texttt{taxize}
(Chamberlain \& Sz{ö}cs 2013) to check each taxon label against the NCBI
database. If a unique match is found, a metadata annotation is added to
the taxon providing the NCBI identification number to the taxonomic
unit.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{birds <-}\StringTok{ }\KeywordTok{taxize_nexml}\NormalTok{(birds, }\StringTok{"NCBI"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If no match is found, the user is warned to check for possible
typographic errors in the taxonomic labels provided. If multiple matches
are found, the user will be prompted to choose between them.

\subsection{Custom metadata
extensions}\label{custom-metadata-extensions}

So far our examples have relied on functions that have a built-in
understanding of the kind of metadata being provided, and can thus
generate the appropriate metadata with little further guidance. In order
to be machine-readable and understandable, NeXML requires all metadata
annotations follow the RDFa format (see Vos et al. (2012)) which
explicitly declares the meaning of the annotation.

Some basic definitions about the XML syntax used to express NeXML will
be helpful for this discussion, though a more comprehensive introduction
can be found in Vos et al. (2012). For instance, consider how the title
we gave to the \texttt{bird.orders} phylogeny appears in the NeXML file
using the XML format:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<meta}\OtherTok{ id=}\StringTok{"m2"}\OtherTok{ property=}\StringTok{"dc:title"}\OtherTok{ datatype=}\StringTok{"xsd:string"}
\OtherTok{      content=}\StringTok{"Phylogeny of the Orders of Birds From Sibley and Ahlquist"}\KeywordTok{/>} 
\end{Highlighting}
\end{Shaded}

The format begins with an XML ``tag'' and the name ``meta'', indicated
by the opening angle bracket; \texttt{\textless{}meta}. A closing tag
\texttt{\textbackslash{}\textgreater{}} indicates the end of this XML
``element'' . This tag contains several ``attributes'', named ``id'',
``property'', etc., that an R user can think of as names in a
\texttt{list}. What follows the equals sign after the attribute name is
called the attribute ``value'', (e.g.~the \texttt{id} attribute has
value ``m2'').

The name of any element (like ``meta'') or attribute (like ``id'') in
XML must be associated with a particular dictionary called a
``namespace'' and specified using a ``prefix'' of an abbreviation
followed by a colon appearing before the name. If no prefix is given, as
is the case for all attributes here: \texttt{id}, \texttt{property},
\texttt{datatype}, and \texttt{content}, then a default prefix specified
at the beginning of the document applies, in this case, the NeXML
namespace. This allows users to combine different XML that have
different definitions of terms like \texttt{id} or \texttt{property}.

The example element above also uses namespaces on some of the attribute
values themselves. This is a consequence of RDFa annotation, and not
strictly part of XML, though it works much the same way. While we hope
the following examples will make these concepts clearer, users do not
need to understand XML and namespaces to use most of the basic
annotation features provided by \texttt{RNeXML}.

So much for the structure; we can now briefly explain the meaning of
this element. We see the title appears as the value of the
\texttt{content} attribute of this \texttt{meta} element. The
\texttt{id} attribute provides us with a unique way to refer to this
meta element in this document. The \texttt{datatype} tells us that the
content is a text string (as opposed to, say, a numerical or boolean
value). The \texttt{property} is the attribute that most interests us
here; it tells us that the content is a title. The prefix \texttt{dc}
indicates the vocabulary (here identified as an XML namespace) to which
the word \texttt{title} belongs. The prefix is defined elsewhere in the
NeXML file, as we can see with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prefixes <-}\StringTok{ }\KeywordTok{get_namespaces}\NormalTok{(birds)}
\NormalTok{prefixes[}\StringTok{"dc"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                                dc 
"http://purl.org/dc/elements/1.1/" 
\end{verbatim}

This URL links us to a web page providing both a human and
machine-readable version of precisely what the term \texttt{title}
means, showing us that it refers to \texttt{title} in the sense of a
creative work, rather than the title of a person, a legal title, the
verb title, etc. This precision can allow us to perform precise computer
reasoning on metadata, without relying on heuristics or assumptions, as
we illustrate later. For the moment though, the need to refer to an
explicit controlled vocabulary (or ontology) with a url, saying
``dc:title'' rather than just saying the property is ``title'', is
something of a burden in creating metadata. The previous examples
involve functions that already know what kind of metadata is being
provided (a title, a data creator, etc), and so can provide the
appropriate vocabulary automatically. The main advantage of linking to
an external vocabulary, however, is the ability to express concepts that
are not already ``built in'' to the data model. \texttt{RNeXML} provides
tools to generate arbitrary metadata annotations given an external
vocabulary, such as we illustrate here.

From the list of namespaces in \texttt{prefixes}, we can follow links to
a handful of established vocabularies and find terms that are not
included in \texttt{add\_basic\_meta()}. For instance, by resolving the
location identified by the \texttt{prism} prefix,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prefixes[}\StringTok{"prism"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                                           prism 
"http://prismstandard.org/namespaces/1.2/basic/" 
\end{verbatim}

we will find that there is a term for \texttt{modificationDate} for a
file. We create a \texttt{meta} element containing this annotation using
the \texttt{meta} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{modified <-}\StringTok{ }\KeywordTok{meta}\NormalTok{(}\DataTypeTok{property =} \StringTok{"prism:modificationDate"}\NormalTok{, }\DataTypeTok{content =} \StringTok{"2013-10-04"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can add this annotation to our existing \texttt{birds} NeXML file
using the \texttt{add\_meta()} function. Because we do not specify a
level, it is added to the root node, referring to the NeXML file as a
whole.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{birds <-}\StringTok{ }\KeywordTok{add_meta}\NormalTok{(modified, birds) }
\end{Highlighting}
\end{Shaded}

The built-in vocabularies are just the tip of the iceberg of established
vocabularies. Here we add an annotation from the \texttt{skos} namespace
which describes the history of where the data comes from:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{history <-}\StringTok{ }\KeywordTok{meta}\NormalTok{(}\DataTypeTok{property =} \StringTok{"skos:historyNote"}\NormalTok{,}
  \DataTypeTok{content =} \StringTok{"Mapped from the bird.orders data in the ape package using RNeXML"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Because \texttt{skos} is not in the current namespace list, we add it
with a url when adding this meta element. We also specify that this
annotation be placed at the level of the \texttt{trees} sub-node in the
NeXML file.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{birds <-}\StringTok{ }\KeywordTok{add_meta}\NormalTok{(history, }
                \NormalTok{birds, }
                \DataTypeTok{level =} \StringTok{"trees"}\NormalTok{,}
                \DataTypeTok{namespaces =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{skos =} \StringTok{"http://www.w3.org/2004/02/skos/core#"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

For finer control of the level at which a \texttt{meta} element is
added, we will manipulate the \texttt{nexml} R object directly using S4
sub-setting, as shown in the supplement.

Much richer metadata annotation is possible. Later we illustrate how
metadata annotation can be used to extend the base NeXML format to
represent new forms of data while maintaining compatibility with any
NeXML parser. The \texttt{RNeXML} package can be easily extended to
support helper functions such as \texttt{taxize\_nexml} to add
additional metadata without imposing a large burden on the user.

\subsection{Reading NeXML metadata}\label{reading-nexml-metadata}

A call to the \texttt{nexml} object prints some metadata summarizing the
data structure:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{birds}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
A nexml object representing:
     1 phylogenetic tree blocks, where: 
     block 1 contains 1 phylogenetic trees 
     44 meta elements 
     0 character matrices 
     23 taxonomic units 
 Taxa:   Struthioniformes, Tinamiformes, Craciformes, Galliformes, Anseriformes, Turniciformes ... 

 NeXML generated by RNeXML using schema version: 0.9 
 size: 370.7 Kb 
\end{verbatim}

We can extract all metadata pertaining to the NeXML document as a whole
(annotations of the XML root node,
\texttt{\textless{}nexml\textgreater{}}) with the command

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meta <-}\StringTok{ }\KeywordTok{get_metadata}\NormalTok{(birds) }
\end{Highlighting}
\end{Shaded}

This returns a named list of available metadata. We can see the kinds of
metadata recorded from the names (showing the first 4):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(meta)[}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "dc:title"                      "dc:creator"                   
[3] "dc:description"                "dcterms:bibliographicCitation"
\end{verbatim}

and can ask for a particular element using the standard list sub-setting
mechanism (i.e.~either the name of an element or its numeric position),

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{meta[[}\StringTok{"dc:title"}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Phylogeny of the Orders of Birds From Sibley and Ahlquist"
\end{verbatim}

All metadata terms must belong to an explicit \emph{namespace} or
vocabulary that allows a computer to interpret the term precisely. The
prefix (before the \texttt{:}) indicates to which vocabulary the term
belongs, e.g. \texttt{dc} in this case. The \texttt{get\_namespaces}
function tells us the definition of the vocabulary using a link:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{prefixes <-}\StringTok{ }\KeywordTok{get_namespaces}\NormalTok{(birds)}
\NormalTok{prefixes[}\StringTok{"dc"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                                dc 
"http://purl.org/dc/elements/1.1/" 
\end{verbatim}

Common metadata can be accessed with a few dedicated functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get_citation}\NormalTok{(birds)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Sibley, C. G. and Ahlquist, J. E. (1990) Phylogeny and
     classification of birds: a study in molecular evolution. New
     Haven: Yale University Press. Paradis E, Claude J and Strimmer K (2004). "APE: analyses of
phylogenetics and evolution in R language." _Bioinformatics_,
*20*, pp. 289-290.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get_taxa}\NormalTok{(birds)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "Struthioniformes" "Tinamiformes"     "Craciformes"     
 [4] "Galliformes"      "Anseriformes"     "Turniciformes"   
 [7] "Piciformes"       "Galbuliformes"    "Bucerotiformes"  
[10] "Upupiformes"      "Trogoniformes"    "Coraciiformes"   
[13] "Coliiformes"      "Cuculiformes"     "Psittaciformes"  
[16] "Apodiformes"      "Trochiliformes"   "Musophagiformes" 
[19] "Strigiformes"     "Columbiformes"    "Gruiformes"      
[22] "Ciconiiformes"    "Passeriformes"   
\end{verbatim}

Which returns text from the otu element labels, typically used to define
taxonomic names, rather than text from explicit meta elements.

We can also access metadata at a specific level (or use
\texttt{level=all} to extract all meta elements in a list). Here we show
only the first few results:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{otu_meta <-}\StringTok{ }\KeywordTok{get_metadata}\NormalTok{(birds, }\DataTypeTok{level=}\StringTok{"otu"}\NormalTok{)}
\NormalTok{otu_meta[}\DecValTok{1}\NormalTok{:}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$`tc:toTaxon`
[1] "http://ncbi.nlm.nih.gov/taxonomy/8798"

$`tc:toTaxon`
[1] "http://ncbi.nlm.nih.gov/taxonomy/8802"

$`tc:toTaxon`
[1] "http://ncbi.nlm.nih.gov/taxonomy/8976"

$`tc:toTaxon`
[1] "http://ncbi.nlm.nih.gov/taxonomy/8976"
\end{verbatim}

This approach does not preserve the relationship between the metadata
element and the \texttt{otu} it was annotating, and as such is most
useful for quick visual exploration. Metadata values for specific
elements or sets of elements can always be accessed using the S4
sub-setting mechanisms (see section below).

\subsection{RDF manipulation and SPARQL
queries}\label{rdf-manipulation-and-sparql-queries}

The most powerful way to take advantage of the machine-readable nature
of the metadata involves the construction of SPARQL queries. This
approach can exploit the reasoning and logical deduction capacity of
formal vocabularies (ontologies). For a proper introduction to SPARQL
queries, see Prud'hommeaux (2014) or Hartig (2012)).

The real expressiveness of SPARQL is better illustrated through more
complex examples such as the one shown in the supplementary materials
(which can also be run from R using the command:
\texttt{demo("sparql", "RNeXML")}). This demonstration constructs a
cladogram based on the taxonomic ranks provided in the NeXML. SPARQL
allows us to make explicit use of ontological concepts such as
manipulating sub-classes (i.e.~that ``Genus'' is a subclass of
``Family''), or joining multiple predicates (i.e.~retrieve the NCBI
identifier of the OTU that has taxon rank of ``Order'').

\subsection{Extending the NeXML standard through metadata
annotation.}\label{extending-the-nexml-standard-through-metadata-annotation.}

No data standard can anticipate all the uses and extensions researchers
may one day need. Researchers have repeatedly adapted the existing NEXUS
file format to accommodate encoding new kinds of information, but in the
process break compatibility between different flavors of NEXUS files,
with few reliable methods to distinguish between these flavors. NeXML
provides a solution to this problem through the use of metadata
annotation.

Here we illustrate this process using the example of stochastic
character mapping (Huelsenbeck \emph{et al.} 2003). A stochastic
character map is simply an annotation of the branches on a phylogeny,
assigning each section of each branch to a particular ``state''
(typically of a morphological characteristic).

Bollback (2006) provides a widely used stand-alone software
implementation of this method in the software \texttt{simmap}, which
modified the standard Newick tree format to express this additional
information. This can break compatibility with other software,\footnote{By
  using the commenting mechanism of the Newick format, it is possible
  that other software that doesn't also use the comment mechanism for
  some other such purpose would be able to successfully parse the tree.
  However there is no way to guarantee that this is the case or for the
  data format to describe its use.} and creates a format that cannot be
interpreted without additional information describing this convention.
By contrast, the NeXML extension is not only backwards compatible but
contains a precise and machine-readable description of what it is
encoding.

In this example, we illustrate how the additional information required
to define a stochastic character mapping (a \texttt{simmap} mapping) in
NeXML.

Revell (2012) describes the \texttt{phytools} package for R, which
includes utilities for reading, manipulating, and writing
\texttt{simmap} files in R. In this example, we also show how to define
\texttt{RNeXML} functions that map the R representation used by Revell
(an extension of the \texttt{ape} class) into the NeXML extension we
have defined by using \texttt{RNeXML} functions.

Since a stochastic character map simply assigns different states to
parts of a branch (or edge) on the phylogenetic tree, we can create a
NeXML representation by annotating the \texttt{edge} elements with
appropriate \texttt{meta} elements. These elements need to describe the
character state being assigned and the duration (in terms of
branch-length) that the edge spends in that state (Stochastic character
maps are specific to time-calibrated or ultrametric trees).

NeXML already defines the \texttt{characters} element to handle discrete
character traits (\texttt{nex:char}) and the states they can assume
(\texttt{nex:state}). We will thus reuse the \texttt{characters} element
for this purpose, referring to both the character trait and the states
by the ids assigned to them in that element. (NeXML's convention of
referring to everything by id permits a single canonical definition of
each term, making it clear where additional annotation belongs). For
each edge, we need to indicate:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  That our annotation contains a stochastic character mapping
  reconstruction
\item
  Since many reconstructions are possible for a single edge, we give
  each reconstruction an id
\item
  We indicate for which character trait we are defining the
  reconstruction
\item
  We then indicate which states the character assumes on that edge. For
  each state realized on the edge, that involves stating:

  \begin{itemize}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    the state assignment
  \item
    the duration (length of time) for which the edge spends in the given
    state
  \item
    the order in which the state changes happen (Though we could just
    assume state transitions are listed chronologically, NeXML suggests
    making all data explicit, rather than relying on the structure of
    the data file to convey information).
  \end{itemize}
\end{itemize}

Thus the annotation for an edge that switches from state \texttt{s2} to
state \texttt{s1} of character \texttt{cr1} would be constructed like
this:

\begin{Shaded}
\begin{Highlighting}[]
 \NormalTok{m <-}\StringTok{ }\KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:reconstructions"}\NormalTok{, }\DataTypeTok{children =} \KeywordTok{c}\NormalTok{(}
        \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:reconstruction"}\NormalTok{, }\DataTypeTok{children =} \KeywordTok{c}\NormalTok{(}

          \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:char"}\NormalTok{, }\StringTok{"cr1"}\NormalTok{),}
          \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:stateChange"}\NormalTok{, }\DataTypeTok{children =} \KeywordTok{c}\NormalTok{(}
            \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:order"}\NormalTok{, }\DecValTok{1}\NormalTok{),}
            \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:length"}\NormalTok{, }\StringTok{"0.2030"}\NormalTok{),}
            \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:state"}\NormalTok{, }\StringTok{"s2"}\NormalTok{))),}
          
          \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:char"}\NormalTok{, }\StringTok{"cr1"}\NormalTok{),}
          \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:stateChange"}\NormalTok{, }\DataTypeTok{children =} \KeywordTok{c}\NormalTok{(}
            \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:order"}\NormalTok{, }\DecValTok{2}\NormalTok{),}
            \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:length"}\NormalTok{, }\StringTok{"0.0022"}\NormalTok{),}
            \KeywordTok{meta}\NormalTok{(}\StringTok{"simmap:state"}\NormalTok{, }\StringTok{"s1"}\NormalTok{)))}
          \NormalTok{))))}
\end{Highlighting}
\end{Shaded}

Of course writing out such a definition manually becomes tedious
quickly. Because these are just R commands, we can easily define a
function that can loop over an assignment like this for each edge,
extracting the appropriate order, length and state from an existing R
object such as that provided in the \texttt{phytools}
package.\\Likewise, it is straightforward to define a function that
reads this data using the \texttt{RNeXML} utilities and converts it back
to the \texttt{phytools} package. The full implementation of this
mapping can be seen in the \texttt{simmap\_to\_nexml()} and the
\texttt{nexml\_to\_simmap()} functions provided in the \texttt{RNeXML}
package.

As the code indicates, the key step is simply to define the data in meta
elements. In so doing, we have defined a custom namespace,
\texttt{simmap}, to hold our variables. This allows us to provide a URL
with more detailed descriptions of what each of these elements mean:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nex <-}\StringTok{ }\KeywordTok{add_namespaces}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{simmap =} \StringTok{"https://github.com/ropensci/RNeXML/tree/master/inst/simmap.md"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

At that URL we have posted a simple description of each term.

Using this convention we can generate NeXML files containing
\texttt{simmap} data, read those files into R, and convert them back
into the \texttt{phytools} package format. These simple functions serve
as further illustration of how \texttt{RNeXML} can be used to extend the
NeXML standard. We illustrate their use briefly here, starting with
loading a \texttt{nexml} object containing a \texttt{simmap}
reconstruction into R:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(simmap_ex)}
\end{Highlighting}
\end{Shaded}

The \texttt{get\_trees()} function can be used to return an
\texttt{ape::phylo} tree as usual. \texttt{RNeXML} automatically detects
the \texttt{simmap} reconstruction data and returns includes this in a
\texttt{maps} element of the \texttt{ape::phylo} object, for use with
other \texttt{phytools} functions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phy <-}\StringTok{ }\KeywordTok{nexml_to_simmap}\NormalTok{(simmap_ex)}
\end{Highlighting}
\end{Shaded}

We can then use various functions from \texttt{phytools} designed for
\texttt{simmap} objects (Revell 2012), such as the plotting function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"phytools"}\NormalTok{)}
\KeywordTok{plotSimmap}\NormalTok{(phy)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
no colors provided. using the following legend:
       A        B        C 
 "black"    "red" "green3" 
\end{verbatim}

\begin{figure}[htbp]
\centering
\includegraphics{components/figure/manuscript-Figure1.pdf}
\caption{Stochastic character mapping on a phylogeny, as generated by
the phytools package after parsing the simmap-extended NeXML.}
\end{figure}

Likewise, we can convert the object back in the NeXML format and write
it out to file to be read by other users.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nex <-}\StringTok{ }\KeywordTok{simmap_to_nexml}\NormalTok{(phy) }
\KeywordTok{nexml_write}\NormalTok{(nex, }\StringTok{"simmap.xml"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "simmap.xml"
\end{verbatim}

Though other NeXML parsers (for instance, for Perl or Python) have not
been written explicitly to express \texttt{simmap} data, those parsers
will nonetheless be able to successfully parse this file and expose the
\texttt{simmap} data to the user.

\subsection{Publishing NeXML files from
R}\label{publishing-nexml-files-from-r}

Data archiving is increasingly required by journals in evolutionary
biology and biodiversity (e.g. Rausher et al. (2010)). The burden of
preparing and submitting properly annotated data to archives continues
to be a significant barrier (Tenopir \emph{et al.} 2011; Stodden 2014),
and many phylogenetic trees upon which studies are based are
inaccessible or lost to the research community (Drew \emph{et al.}
2013). \texttt{RNeXML} seeks to lower these barriers by providing
functions to immediately archive NeXML files in scientific repositories.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{doi <-}\StringTok{ }\KeywordTok{nexml_publish}\NormalTok{(birds, }\DataTypeTok{visibility =} \StringTok{"public"}\NormalTok{, }\DataTypeTok{repository=}\StringTok{"figshare"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Robust data archiving need not involve immediate release of the data.
The \texttt{figshare} repository supports the option of
\texttt{visibility = "private"}, allowing secure publication that
provides a way to backup and share data with collaborators prior to
public release.

\section{Software reuse and support}\label{software-reuse-and-support}

The \texttt{RNeXML} package is available through the CRAN repository
under a CC0 license. At the time of writing, the current version is
1.1.3.99. The current development branch can be found on Github at
\href{}{\url{https://github.com/ropensci/RNeXML}}. See the NEWS file for
changes in recent versions. Users are encouraged to submit bug reports
or feature requests in the issues log. Contact
\texttt{ropensci-discuss@googlegroups.com} or the package maintainer for
help, or email the phylogenetics R users group list at
\texttt{r-sig-phylo@r-project.org}.

There are many promising directions for further development of the
\texttt{RNeXML} package. The project's
\href{https://github.com/ropensci/RNeXML/issues/milestones}{Milestones
page} page provides a list of steps currently planned or under
consideration. In particular, these milestones include increased support
for interactive mode of entering data (wizards), conversions to and from
other existing R phylogenetics formats such those found in the
\texttt{phylobase} package (NESCENT R Hackathon Team 2014), and support
for integration of semantics defined through the Web Ontology language
(OWL), as discussed in the Challenges section.

\subsection{Acknowledgements}\label{acknowledgements}

.

This project was supported in part by a grant from the Alfred P Sloan
Foundation Grant 2013-6-22 (CB and SC), NSF Grant DBI-1306697 (CB),
\ldots{} We thank F. Michonneau for helpful comments on an earlier
version of this manuscript. \texttt{RNeXML} is part of the rOpenSci
project, {[}\url{http://ropensci.org}{]}.

Boettiger, C. (2014). \emph{knitcitations: Citations for knitr markdown
files}. Retrieved from \url{https://github.com/cboettig/knitcitations}

Boettiger, C. \& {Temple Lang}, D. (2012). Treebase: an r package for
discovery, access and manipulation of online phylogenies (L. Harmon,
Ed.). \emph{Methods Ecol Evol}, \textbf{3}, 1060--1066. Retrieved from
\url{http://dx.doi.org/10.1111/j.2041-210x.2012.00247.x}

Bollback, J. (2006).\emph{BMC Bioinformatics}, \textbf{7}, 88. Retrieved
from \url{http://dx.doi.org/10.1186/1471-2105-7-88}

Chamberlain, S.A. \& Sz{ö}cs, E. (2013). taxize: taxonomic search and
retrieval in r. \emph{F1000Research}. Retrieved from
\url{http://dx.doi.org/10.12688/f1000research.2-191.v2}

Cranston, K., Harmon, L.J., O'Leary, M.A. \& Lisle, C. (2014). Best
practices for data sharing in phylogenetic research. \emph{PLoS Curr}.
Retrieved from
\url{http://dx.doi.org/10.1371/currents.tol.bf01eff4a6b60ca4825c69293dc59645}

Drew, B.T., Gazis, R., Cabezas, P., Swithers, K.S., Deng, J., Rodriguez,
R., Katz, L.A., Crandall, K.A., Hibbett, D.S. \& Soltis, D.E. (2013).
Lost branches on the tree of life. \emph{PLoS Biol}, \textbf{11},
e1001636. Retrieved from
\url{http://dx.doi.org/10.1371/journal.pbio.1001636}

Harmon, L., Weir, J., Brock, C., Glor, R. \& Challenger, W. (2008).
GEIGER: investigating evolutionary radiations. \emph{Bioinformatics},
\textbf{24}, 129--131.

Hartig, O. (2012). An introduction to sPARQL and queries over linked
data. \emph{Web engineering} pp. 506--507. Springer Science + Business
Media. Retrieved from
\url{http://dx.doi.org/10.1007/978-3-642-31753-8_56}

Huelsenbeck, J.P., Nielsen, R. \& Bollback, J.P. (2003). Stochastic
mapping of morphological characters. \emph{Systematic Biology},
\textbf{52}, 131--158. Retrieved from
\url{http://dx.doi.org/10.1080/10635150390192780}

NESCENT R Hackathon Team. (2014). \emph{phylobase: Base package for
phylogenetic structures and comparative data}. Retrieved from
\url{http://CRAN.R-project.org/package=phylobase}

O'Meara, B. (2014). CRAN task view: Phylogenetics, especially
comparative methods. Retrieved from
\url{http://cran.r-project.org/web/views/Phylogenetics.html}

Paradis, E., Claude, J. \& Strimmer, K. (2004). APE: analyses of
phylogenetics and evolution in R language. \emph{Bioinformatics},
\textbf{20}, 289--290.

Prud'hommeaux, E. (2014). SPARQL query language for rDF. \emph{W3C}.
Retrieved from \url{http://www.w3.org/TR/rdf-sparql-query/}

R Core Team. (2014). \emph{R: A language and environment for statistical
computing}. R Foundation for Statistical Computing, Vienna, Austria.
Retrieved from \url{http://www.R-project.org/}

Rausher, M.D., McPeek, M.A., Moore, A.J., Rieseberg, L. \& Whitlock,
M.C. (2010). Data archiving. \emph{Evolution}, \textbf{64}, 603--604.
Retrieved from \url{http://dx.doi.org/10.1111/j.1558-5646.2009.00940.x}

Revell, L.J. (2012). phytools: An r package for phylogenetic comparative
biology (and other things). \emph{Methods in Ecology and Evolution},
\textbf{3}, 217--223.

Stodden, V. (2014). The scientific method in practice: Reproducibility
in the computational sciences. \emph{SSRN Journal}. Retrieved from
\url{http://dx.doi.org/10.2139/ssrn.1550193}

Stoltzfus, A., O'Meara, B., Whitacre, J., Mounce, R., Gillespie, E.L.,
Kumar, S., Rosauer, D.F. \& Vos, R.A. (2012). Sharing and re-use of
phylogenetic trees (and associated data) to facilitate synthesis.
\emph{BMC Research Notes}, \textbf{5}, 574. Retrieved from
\url{http://dx.doi.org/10.1186/1756-0500-5-574}

Tenopir, C., Allard, S., Douglass, K., Aydinoglu, A.U., Wu, L., Read,
E., Manoff, M. \& Frame, M. (2011). Data sharing by scientists:
Practices and perceptions (C. Neylon, Ed.). \emph{PLoS ONE}, \textbf{6},
e21101. Retrieved from
\url{http://dx.doi.org/10.1371/journal.pone.0021101}

Vos, R.A., Balhoff, J.P., Caravas, J.A., Holder, M.T., Lapp, H.,
Maddison, W.P., Midford, P.E., Priyam, A., Sukumaran, J., Xia, X. \&
Stoltzfus, A. (2012). NeXML: Rich, extensible, and verifiable
representation of comparative data and metadata. \emph{Systematic
Biology}, \textbf{61}, 675--689. Retrieved from
\url{http://dx.doi.org/10.1093/sysbio/sys025}

Xie, Y. (2013). \emph{Dynamic documents with R and knitr}. Chapman;
Hall/CRC, Boca Raton, Florida. Retrieved from
\url{http://yihui.name/knitr/}

\end{document}


